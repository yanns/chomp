<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `ParseResult` struct in crate `chomp`.">
    <meta name="keywords" content="rust, rustlang, rust-lang, ParseResult">

    <title>chomp::ParseResult - Rust</title>

    <link rel="stylesheet" type="text/css" href="../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../main.css">
    

    
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        
        <p class='location'><a href='index.html'>chomp</a></p><script>window.sidebarCurrent = {name: 'ParseResult', ty: 'struct', relpath: ''};</script><script defer src="sidebar-items.js"></script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content struct">
<h1 class='fqn'><span class='in-band'>Struct <a href='index.html'>chomp</a>::<wbr><a class='struct' href=''>ParseResult</a></span><span class='out-of-band'><span id='render-detail'>
                   <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                       [<span class='inner'>&#x2212;</span>]
                   </a>
               </span><a id='src-624' class='srclink' href='../src/chomp/src/parse_result.rs.html#81' title='goto source code'>[src]</a></span></h1>
<pre class='rust struct'>#[must_use]
pub struct ParseResult&lt;'a, I: 'a, T: 'a, E: 'a&gt;(_);</pre><div class='docblock'><p>The basic return type of a parser.</p>

<p>This type satisfies a variant of the <code>Monad</code> typeclass. Due to the limitations of Rust&#39;s
return types closures cannot be returned without boxing which has an unacceptable performance
impact.</p>

<p>To get around this issue and still provide a simple to use and safe (as in hard to accidentally
violate the monad laws or the assumptions taken by the parser type) an <code>Input</code> wrapper is
provided which ensures that the parser state is carried properly through every call to <code>bind</code>.
This is also known as a Linear Type (emulated through hiding destructors and using the
annotation <code>#[must_use]</code>).</p>

<p>Do-notation is provided by the macro <code>parse!</code>.</p>

<h1 id='equivalence-with-haskells-monad-typeclass' class='section-header'><a href='#equivalence-with-haskells-monad-typeclass'>Equivalence with Haskell&#39;s <code>Monad</code> typeclass:</a></h1>
<pre><code class="language-text">f &gt;&gt;= g   ≡  f(m).bind(g)
f &gt;&gt; g    ≡  f(m).then(g)
return a  ≡  m.ret(a)
fail a    ≡  m.err(a)
</code></pre>

<p>It also satisfies the monad laws:</p>

<pre><code class="language-text">return a &gt;&gt;= f   ≡  f a
m &gt;&gt;= return     ≡  m
(m &gt;&gt;= f) &gt;&gt;= g  ≡  m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)
</code></pre>
</div><h2 id='methods'>Methods</h2><h3 class='impl'><code>impl&lt;'a, I, T, E&gt; <a class='struct' href='../chomp/struct.ParseResult.html' title='chomp::ParseResult'>ParseResult</a>&lt;'a, I, T, E&gt;</code></h3><div class='impl-items'><h4 id='method.bind' class='method'><code>fn <a href='#method.bind' class='fnname'>bind</a>&lt;F, U, V&gt;(self, f: F) -&gt; <a class='struct' href='../chomp/struct.ParseResult.html' title='chomp::ParseResult'>ParseResult</a>&lt;'a, I, U, V&gt; <span class='where'>where F: <a class='trait' href='https://doc.rust-lang.org/nightly/core/ops/trait.FnOnce.html' title='core::ops::FnOnce'>FnOnce</a>(<a class='struct' href='../chomp/struct.Input.html' title='chomp::Input'>Input</a>&lt;'a, I&gt;, T) -&gt; <a class='struct' href='../chomp/struct.ParseResult.html' title='chomp::ParseResult'>ParseResult</a>&lt;'a, I, U, V&gt;, V: <a class='trait' href='https://doc.rust-lang.org/nightly/core/convert/trait.From.html' title='core::convert::From'>From</a>&lt;E&gt;</span></code></h4>
<div class='docblock'><p>Sequentially composes the result with a parse action <code>f</code>, passing any produced value as
the second parameter.</p>

<p>The first parameter to the supplied function <code>f</code> is the parser state (<code>Input</code>). This
state is then passed on to other parsers or used to return a value or an error.</p>

<h1 id='automatic-conversion-of-e' class='section-header'><a href='#automatic-conversion-of-e'>Automatic conversion of <code>E</code></a></h1>
<p>The error value <code>E</code> will automatically be converted using the <code>From</code> trait to the
desired type. The downside with this using the current stable version of Rust (1.4) is that
the type inferrence will currently not use the default value for the generic <code>V</code> and will
therefore require extra type hint for the error.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>chomp</span>::<span class='ident'>parse_only</span>;

<span class='kw'>let</span> <span class='ident'>r</span> <span class='op'>=</span> <span class='ident'>parse_only</span>(<span class='op'>|</span><span class='ident'>i</span><span class='op'>|</span> {
        <span class='ident'>i</span>.<span class='ident'>ret</span>(<span class='string'>&quot;data&quot;</span>.<span class='ident'>to_owned</span>())
        <span class='comment'>// Explicitly state the error type</span>
         .<span class='ident'>bind</span>::<span class='op'>&lt;</span>_, _, ()<span class='op'>&gt;</span>(<span class='op'>|</span><span class='ident'>i</span>, <span class='ident'>x</span><span class='op'>|</span> <span class='ident'>i</span>.<span class='ident'>ret</span>(<span class='ident'>x</span> <span class='op'>+</span> <span class='string'>&quot; here!&quot;</span>))
    },
    <span class='string'>b&quot;test&quot;</span>);

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>r</span>, <span class='prelude-val'>Ok</span>(<span class='string'>&quot;data here!&quot;</span>.<span class='ident'>to_owned</span>()));</pre>

<p>Wrapping the expression in a function will both make it easier to compose and also provides
the type-hint for the error in the function signature:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>chomp</span>::{<span class='ident'>Input</span>, <span class='ident'>ParseResult</span>, <span class='ident'>parse_only</span>};

<span class='kw'>fn</span> <span class='ident'>parser</span>(<span class='ident'>i</span>: <span class='ident'>Input</span><span class='op'>&lt;</span><span class='ident'>u8</span><span class='op'>&gt;</span>, <span class='ident'>n</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>ParseResult</span><span class='op'>&lt;</span><span class='ident'>u8</span>, <span class='ident'>i32</span>, ()<span class='op'>&gt;</span> {
    <span class='ident'>i</span>.<span class='ident'>ret</span>(<span class='ident'>n</span> <span class='op'>+</span> <span class='number'>10</span>)
}

<span class='kw'>let</span> <span class='ident'>r</span> <span class='op'>=</span> <span class='ident'>parse_only</span>(<span class='op'>|</span><span class='ident'>i</span><span class='op'>|</span> <span class='ident'>i</span>.<span class='ident'>ret</span>(<span class='number'>23</span>).<span class='ident'>bind</span>(<span class='ident'>parser</span>), <span class='string'>b&quot;test&quot;</span>);

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>r</span>, <span class='prelude-val'>Ok</span>(<span class='number'>33</span>));</pre>
</div><h4 id='method.then' class='method'><code>fn <a href='#method.then' class='fnname'>then</a>&lt;F, U, V&gt;(self, f: F) -&gt; <a class='struct' href='../chomp/struct.ParseResult.html' title='chomp::ParseResult'>ParseResult</a>&lt;'a, I, U, V&gt; <span class='where'>where F: <a class='trait' href='https://doc.rust-lang.org/nightly/core/ops/trait.FnOnce.html' title='core::ops::FnOnce'>FnOnce</a>(<a class='struct' href='../chomp/struct.Input.html' title='chomp::Input'>Input</a>&lt;'a, I&gt;) -&gt; <a class='struct' href='../chomp/struct.ParseResult.html' title='chomp::ParseResult'>ParseResult</a>&lt;'a, I, U, V&gt;, V: <a class='trait' href='https://doc.rust-lang.org/nightly/core/convert/trait.From.html' title='core::convert::From'>From</a>&lt;E&gt;</span></code></h4>
<div class='docblock'><p>Sequentially composes the result with a parse action <code>f</code>, discarding any produced value.</p>

<p>The first parameter to the supplied function <code>f</code> is the parser state (<code>Input</code>). This
state is then passed on to other parsers or used to return a value or an error.</p>

<h1 id='relation-to-bind' class='section-header'><a href='#relation-to-bind'>Relation to <code>bind</code></a></h1>
<pre><code class="language-text">ParseResult::then(g)  ≡  ParseResult::bind(|i, _| g(i))
</code></pre>

<h1 id='example' class='section-header'><a href='#example'>Example</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>chomp</span>::{<span class='ident'>Input</span>, <span class='ident'>U8Result</span>, <span class='ident'>parse_only</span>};

<span class='kw'>fn</span> <span class='ident'>g</span>(<span class='ident'>i</span>: <span class='ident'>Input</span><span class='op'>&lt;</span><span class='ident'>u8</span><span class='op'>&gt;</span>) <span class='op'>-&gt;</span> <span class='ident'>U8Result</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='lifetime'>&#39;static</span> <span class='ident'>str</span><span class='op'>&gt;</span> {
    <span class='ident'>i</span>.<span class='ident'>ret</span>(<span class='string'>&quot;testing!&quot;</span>)
}

<span class='kw'>let</span> <span class='ident'>r1</span> <span class='op'>=</span> <span class='ident'>parse_only</span>(<span class='op'>|</span><span class='ident'>i</span><span class='op'>|</span> <span class='ident'>i</span>.<span class='ident'>ret</span>(<span class='string'>&quot;initial state&quot;</span>).<span class='ident'>bind</span>(<span class='op'>|</span><span class='ident'>i</span>, _<span class='op'>|</span> <span class='ident'>g</span>(<span class='ident'>i</span>)), <span class='string'>b&quot;data&quot;</span>);
<span class='kw'>let</span> <span class='ident'>r2</span> <span class='op'>=</span> <span class='ident'>parse_only</span>(<span class='op'>|</span><span class='ident'>i</span><span class='op'>|</span> <span class='ident'>i</span>.<span class='ident'>ret</span>(<span class='string'>&quot;initial state&quot;</span>).<span class='ident'>then</span>(<span class='ident'>g</span>), <span class='string'>b&quot;data&quot;</span>);

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>r1</span>, <span class='prelude-val'>Ok</span>(<span class='string'>&quot;testing!&quot;</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>r2</span>, <span class='prelude-val'>Ok</span>(<span class='string'>&quot;testing!&quot;</span>));</pre>
</div><h4 id='method.map' class='method'><code>fn <a href='#method.map' class='fnname'>map</a>&lt;U, F&gt;(self, f: F) -&gt; <a class='struct' href='../chomp/struct.ParseResult.html' title='chomp::ParseResult'>ParseResult</a>&lt;'a, I, U, E&gt; <span class='where'>where F: <a class='trait' href='https://doc.rust-lang.org/nightly/core/ops/trait.FnOnce.html' title='core::ops::FnOnce'>FnOnce</a>(T) -&gt; U</span></code></h4>
<div class='docblock'><p>Applies the function <code>f</code> on the contained data if the parser is in a success state.</p>

<h1 id='example-1' class='section-header'><a href='#example-1'>Example</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>chomp</span>::{<span class='ident'>parse_only</span>, <span class='ident'>any</span>};

<span class='kw'>let</span> <span class='ident'>r</span> <span class='op'>=</span> <span class='ident'>parse_only</span>(<span class='op'>|</span><span class='ident'>i</span><span class='op'>|</span> <span class='ident'>any</span>(<span class='ident'>i</span>).<span class='ident'>map</span>(<span class='op'>|</span><span class='ident'>c</span><span class='op'>|</span> <span class='ident'>c</span> <span class='op'>+</span> <span class='number'>12</span>), <span class='string'>b&quot;abc&quot;</span>);

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>r</span>, <span class='prelude-val'>Ok</span>(<span class='string'>b&#39;m&#39;</span>));</pre>
</div><h4 id='method.map_err' class='method'><code>fn <a href='#method.map_err' class='fnname'>map_err</a>&lt;V, F&gt;(self, f: F) -&gt; <a class='struct' href='../chomp/struct.ParseResult.html' title='chomp::ParseResult'>ParseResult</a>&lt;'a, I, T, V&gt; <span class='where'>where F: <a class='trait' href='https://doc.rust-lang.org/nightly/core/ops/trait.FnOnce.html' title='core::ops::FnOnce'>FnOnce</a>(E) -&gt; V</span></code></h4>
<div class='docblock'><p>Applies the function <code>f</code> on the contained error if the parser is in an error state.</p>

<h1 id='example-2' class='section-header'><a href='#example-2'>Example</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>chomp</span>::{<span class='ident'>ParseError</span>, <span class='ident'>parse_only</span>};

<span class='kw'>let</span> <span class='ident'>r</span> <span class='op'>=</span> <span class='ident'>parse_only</span>(<span class='op'>|</span><span class='ident'>i</span><span class='op'>|</span> <span class='ident'>i</span>.<span class='ident'>err</span>::<span class='op'>&lt;</span>(), _<span class='op'>&gt;</span>(<span class='string'>&quot;this is&quot;</span>)
         .<span class='ident'>map_err</span>(<span class='op'>|</span><span class='ident'>e</span><span class='op'>|</span> <span class='ident'>e</span>.<span class='ident'>to_owned</span>() <span class='op'>+</span> <span class='string'>&quot; an error&quot;</span>),
         <span class='string'>b&quot;foo&quot;</span>);

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>r</span>, <span class='prelude-val'>Err</span>(<span class='ident'>ParseError</span>::<span class='ident'>Error</span>(<span class='string'>b&quot;foo&quot;</span>, <span class='string'>&quot;this is an error&quot;</span>.<span class='ident'>to_owned</span>())));</pre>
</div><h4 id='method.inspect' class='method'><code>fn <a href='#method.inspect' class='fnname'>inspect</a>&lt;F&gt;(self, f: F) -&gt; <a class='struct' href='../chomp/struct.ParseResult.html' title='chomp::ParseResult'>ParseResult</a>&lt;'a, I, T, E&gt; <span class='where'>where F: <a class='trait' href='https://doc.rust-lang.org/nightly/core/ops/trait.FnOnce.html' title='core::ops::FnOnce'>FnOnce</a>(&amp;T)</span></code></h4>
<div class='docblock'><p>Calls the function <code>f</code> with a reference of the contained data if the parser is in a success
state.</p>

<h1 id='example-3' class='section-header'><a href='#example-3'>Example</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>chomp</span>::{<span class='ident'>parse_only</span>, <span class='ident'>take_while</span>};

<span class='kw'>let</span> <span class='ident'>r</span> <span class='op'>=</span> <span class='ident'>parse_only</span>(<span class='op'>|</span><span class='ident'>i</span><span class='op'>|</span> <span class='ident'>take_while</span>(<span class='ident'>i</span>, <span class='op'>|</span><span class='ident'>c</span><span class='op'>|</span> <span class='ident'>c</span> <span class='op'>!=</span> <span class='string'>b&#39; &#39;</span>).<span class='ident'>inspect</span>(<span class='op'>|</span><span class='ident'>b</span><span class='op'>|</span> {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{:?}&quot;</span>, <span class='ident'>b</span>); <span class='comment'>// Prints &quot;test&quot;</span>
}), <span class='string'>b&quot;test and more&quot;</span>);

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>r</span>, <span class='prelude-val'>Ok</span>(<span class='kw-2'>&amp;</span><span class='string'>b&quot;test&quot;</span>[..]));</pre>
</div></div><h2 id='implementations'>Trait Implementations</h2><h3 class='impl'><code>impl&lt;'a, I, T, E&gt; <a class='trait' href='../chomp/primitives/trait.IntoInner.html' title='chomp::primitives::IntoInner'>IntoInner</a> for <a class='struct' href='../chomp/struct.ParseResult.html' title='chomp::ParseResult'>ParseResult</a>&lt;'a, I, T, E&gt;</code></h3><div class='docblock'><p><strong>Primitive:</strong> Consumes the <code>ParseResult</code> and exposes the internal state.</p>

<h1 id='primitive' class='section-header'><a href='#primitive'>Primitive</a></h1>
<p>Only used by fundamental parsers and combinators.</p>

<h1 id='motivation' class='section-header'><a href='#motivation'>Motivation</a></h1>
<p>The <code>ParseResult</code> type is a semi-linear type, supposed to act like a linear type while used in
a parsing context to carry the state. Normally it should be as restrictive as the <code>Input</code> type
in terms of how much it exposes its internals, but the <code>IntoInner</code> trait implementation
allows fundamental parsers and combinators to expose the inner <code>State</code> of the <code>ParseResult</code>
and act on this.</p>

<h1 id='example-4' class='section-header'><a href='#example-4'>Example</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>chomp</span>::{<span class='ident'>Input</span>, <span class='ident'>ParseResult</span>, <span class='ident'>parse_only</span>, <span class='ident'>take</span>};
<span class='kw'>use</span> <span class='ident'>chomp</span>::<span class='ident'>primitives</span>::{<span class='ident'>InputClone</span>, <span class='ident'>IntoInner</span>, <span class='ident'>State</span>};

<span class='comment'>// Version of option() which also catches incomplete</span>
<span class='kw'>fn</span> <span class='ident'>my_combinator</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>I</span>, <span class='ident'>T</span>, <span class='ident'>E</span>, <span class='ident'>F</span><span class='op'>&gt;</span>(<span class='ident'>i</span>: <span class='ident'>Input</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>I</span><span class='op'>&gt;</span>, <span class='ident'>f</span>: <span class='ident'>F</span>, <span class='ident'>default</span>: <span class='ident'>T</span>) <span class='op'>-&gt;</span> <span class='ident'>ParseResult</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>I</span>, <span class='ident'>T</span>, <span class='ident'>E</span><span class='op'>&gt;</span>
  <span class='kw'>where</span> <span class='ident'>F</span>: <span class='ident'>FnOnce</span>(<span class='ident'>Input</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>I</span><span class='op'>&gt;</span>) <span class='op'>-&gt;</span> <span class='ident'>ParseResult</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>I</span>, <span class='ident'>T</span>, <span class='ident'>E</span><span class='op'>&gt;</span> {
    <span class='kw'>match</span> <span class='ident'>f</span>(<span class='ident'>i</span>.<span class='ident'>clone</span>()).<span class='ident'>into_inner</span>() {
        <span class='comment'>// Data, preserve the buffer and return</span>
        <span class='ident'>State</span>::<span class='ident'>Data</span>(<span class='ident'>b</span>, <span class='ident'>d</span>) <span class='op'>=&gt;</span> <span class='ident'>b</span>.<span class='ident'>ret</span>(<span class='ident'>d</span>),
        <span class='comment'>// Not data, use original buffer and return default</span>
        _                 <span class='op'>=&gt;</span> <span class='ident'>i</span>.<span class='ident'>ret</span>(<span class='ident'>default</span>),
    }
}

<span class='kw'>let</span> <span class='ident'>r</span> <span class='op'>=</span> <span class='ident'>parse_only</span>(<span class='op'>|</span><span class='ident'>i</span><span class='op'>|</span> <span class='ident'>my_combinator</span>(<span class='ident'>i</span>, <span class='op'>|</span><span class='ident'>i</span><span class='op'>|</span> <span class='ident'>take</span>(<span class='ident'>i</span>, <span class='number'>10</span>), <span class='kw-2'>&amp;</span><span class='string'>b&quot;test&quot;</span>[..]), <span class='string'>b&quot;foo&quot;</span>);

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>r</span>, <span class='prelude-val'>Ok</span>(<span class='kw-2'>&amp;</span><span class='string'>b&quot;test&quot;</span>[..]));</pre>
</div><div class='impl-items'><h4 id='associatedtype.Inner' class='type'><code>type <a href='../chomp/primitives/trait.IntoInner.html#associatedtype.Inner' class='type'>Inner</a> = <a class='enum' href='../chomp/primitives/enum.State.html' title='chomp::primitives::State'>State</a>&lt;'a, I, T, E&gt;</code></h4>
<h4 id='method.into_inner' class='method'><code>fn <a href='../chomp/primitives/trait.IntoInner.html#tymethod.into_inner' class='fnname'>into_inner</a>(self) -&gt; Self::<a class='trait' href='../chomp/primitives/trait.IntoInner.html' title='chomp::primitives::IntoInner'>Inner</a></code></h4>
</div><h3 id='derived_implementations'>Derived Implementations </h3><h3 class='impl'><code>impl&lt;'a, I: <a class='trait' href='https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html' title='core::hash::Hash'>Hash</a> + 'a, T: <a class='trait' href='https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html' title='core::hash::Hash'>Hash</a> + 'a, E: <a class='trait' href='https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html' title='core::hash::Hash'>Hash</a> + 'a&gt; <a class='trait' href='https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html' title='core::hash::Hash'>Hash</a> for <a class='struct' href='../chomp/struct.ParseResult.html' title='chomp::ParseResult'>ParseResult</a>&lt;'a, I, T, E&gt;</code></h3><div class='impl-items'><h4 id='method.hash' class='method'><code>fn <a href='https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#tymethod.hash' class='fnname'>hash</a>&lt;__HITE: <a class='trait' href='https://doc.rust-lang.org/nightly/core/hash/trait.Hasher.html' title='core::hash::Hasher'>Hasher</a>&gt;(&amp;self, __arg_0: &amp;mut __HITE)</code></h4>
<h4 id='method.hash_slice' class='method'><span class="since">1.3.0</span><code>fn <a href='https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#method.hash_slice' class='fnname'>hash_slice</a>&lt;H&gt;(data: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>&amp;[Self]</a>, state: &amp;mut H) <span class='where'>where H: <a class='trait' href='https://doc.rust-lang.org/nightly/core/hash/trait.Hasher.html' title='core::hash::Hasher'>Hasher</a></span></code></h4>
</div><h3 class='impl'><code>impl&lt;'a, I: <a class='trait' href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html' title='core::cmp::PartialOrd'>PartialOrd</a> + 'a, T: <a class='trait' href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html' title='core::cmp::PartialOrd'>PartialOrd</a> + 'a, E: <a class='trait' href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html' title='core::cmp::PartialOrd'>PartialOrd</a> + 'a&gt; <a class='trait' href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html' title='core::cmp::PartialOrd'>PartialOrd</a> for <a class='struct' href='../chomp/struct.ParseResult.html' title='chomp::ParseResult'>ParseResult</a>&lt;'a, I, T, E&gt;</code></h3><div class='impl-items'><h4 id='method.partial_cmp' class='method'><code>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp' class='fnname'>partial_cmp</a>(&amp;self, __arg_0: &amp;<a class='struct' href='../chomp/struct.ParseResult.html' title='chomp::ParseResult'>ParseResult</a>&lt;'a, I, T, E&gt;) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a class='enum' href='https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html' title='core::cmp::Ordering'>Ordering</a>&gt;</code></h4>
<h4 id='method.lt' class='method'><code>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.lt' class='fnname'>lt</a>(&amp;self, __arg_0: &amp;<a class='struct' href='../chomp/struct.ParseResult.html' title='chomp::ParseResult'>ParseResult</a>&lt;'a, I, T, E&gt;) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
<h4 id='method.le' class='method'><code>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.le' class='fnname'>le</a>(&amp;self, __arg_0: &amp;<a class='struct' href='../chomp/struct.ParseResult.html' title='chomp::ParseResult'>ParseResult</a>&lt;'a, I, T, E&gt;) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
<h4 id='method.gt' class='method'><code>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.gt' class='fnname'>gt</a>(&amp;self, __arg_0: &amp;<a class='struct' href='../chomp/struct.ParseResult.html' title='chomp::ParseResult'>ParseResult</a>&lt;'a, I, T, E&gt;) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
<h4 id='method.ge' class='method'><code>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.ge' class='fnname'>ge</a>(&amp;self, __arg_0: &amp;<a class='struct' href='../chomp/struct.ParseResult.html' title='chomp::ParseResult'>ParseResult</a>&lt;'a, I, T, E&gt;) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
</div><h3 class='impl'><code>impl&lt;'a, I: <a class='trait' href='https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html' title='core::cmp::Ord'>Ord</a> + 'a, T: <a class='trait' href='https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html' title='core::cmp::Ord'>Ord</a> + 'a, E: <a class='trait' href='https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html' title='core::cmp::Ord'>Ord</a> + 'a&gt; <a class='trait' href='https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html' title='core::cmp::Ord'>Ord</a> for <a class='struct' href='../chomp/struct.ParseResult.html' title='chomp::ParseResult'>ParseResult</a>&lt;'a, I, T, E&gt;</code></h3><div class='impl-items'><h4 id='method.cmp' class='method'><code>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#tymethod.cmp' class='fnname'>cmp</a>(&amp;self, __arg_0: &amp;<a class='struct' href='../chomp/struct.ParseResult.html' title='chomp::ParseResult'>ParseResult</a>&lt;'a, I, T, E&gt;) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html' title='core::cmp::Ordering'>Ordering</a></code></h4>
</div><h3 class='impl'><code>impl&lt;'a, I: <a class='trait' href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html' title='core::cmp::PartialEq'>PartialEq</a> + 'a, T: <a class='trait' href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html' title='core::cmp::PartialEq'>PartialEq</a> + 'a, E: <a class='trait' href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html' title='core::cmp::PartialEq'>PartialEq</a> + 'a&gt; <a class='trait' href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html' title='core::cmp::PartialEq'>PartialEq</a> for <a class='struct' href='../chomp/struct.ParseResult.html' title='chomp::ParseResult'>ParseResult</a>&lt;'a, I, T, E&gt;</code></h3><div class='impl-items'><h4 id='method.eq' class='method'><code>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq' class='fnname'>eq</a>(&amp;self, __arg_0: &amp;<a class='struct' href='../chomp/struct.ParseResult.html' title='chomp::ParseResult'>ParseResult</a>&lt;'a, I, T, E&gt;) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
<h4 id='method.ne' class='method'><code>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#method.ne' class='fnname'>ne</a>(&amp;self, __arg_0: &amp;<a class='struct' href='../chomp/struct.ParseResult.html' title='chomp::ParseResult'>ParseResult</a>&lt;'a, I, T, E&gt;) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
</div><h3 class='impl'><code>impl&lt;'a, I: <a class='trait' href='https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html' title='core::cmp::Eq'>Eq</a> + 'a, T: <a class='trait' href='https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html' title='core::cmp::Eq'>Eq</a> + 'a, E: <a class='trait' href='https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html' title='core::cmp::Eq'>Eq</a> + 'a&gt; <a class='trait' href='https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html' title='core::cmp::Eq'>Eq</a> for <a class='struct' href='../chomp/struct.ParseResult.html' title='chomp::ParseResult'>ParseResult</a>&lt;'a, I, T, E&gt;</code></h3><div class='impl-items'></div><h3 class='impl'><code>impl&lt;'a, I: <a class='trait' href='https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html' title='core::fmt::Debug'>Debug</a> + 'a, T: <a class='trait' href='https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html' title='core::fmt::Debug'>Debug</a> + 'a, E: <a class='trait' href='https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html' title='core::fmt::Debug'>Debug</a> + 'a&gt; <a class='trait' href='https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html' title='core::fmt::Debug'>Debug</a> for <a class='struct' href='../chomp/struct.ParseResult.html' title='chomp::ParseResult'>ParseResult</a>&lt;'a, I, T, E&gt;</code></h3><div class='impl-items'><h4 id='method.fmt' class='method'><code>fn <a href='https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt' class='fnname'>fmt</a>(&amp;self, __arg_0: &amp;mut <a class='struct' href='https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html' title='core::fmt::Formatter'>Formatter</a>) -&gt; <a class='type' href='https://doc.rust-lang.org/nightly/core/fmt/type.Result.html' title='core::fmt::Result'>Result</a></code></h4>
</div></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../";
        window.currentCrate = "chomp";
        window.playgroundUrl = "";
    </script>
    <script src="../jquery.js"></script>
    <script src="../main.js"></script>
    
    <script defer src="../search-index.js"></script>
</body>
</html>