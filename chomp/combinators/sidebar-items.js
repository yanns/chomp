initSidebarItems({"fn":[["count","Applies the parser ``p`` exactly ``num`` times collecting all items into `T: FromIterator`."],["look_ahead","Applies the parser `F` without consuming any input."],["many","Parses many instances of ``f`` until it does no longer match, collecting all matches into the type `T: FromIterator`."],["many1","Parses at least one instance of ``f`` and continues until it does no longer match, collecting all matches into the type `T: FromIterator`."],["many_till","Applies the parser `R` multiple times until the parser `F` succeeds and returns a `T: FromIterator` populated by the values yielded by `R`. Consumes the matched part of `F`."],["matched_by","Returns the result of the given parser as well as the slice which matched it."],["option","Tries the parser ``f``, on success it yields the parsed value, on failure ``default`` will be yielded instead."],["or","Tries to match the parser ``f``, if ``f`` fails it tries ``g``. Returns the success value of the first match, otherwise the error of the last one if both fail."],["sep_by","Applies the parser `R` zero or more times, separated by the parser `F`. All matches from `R` will be collected into the type `T: FromIterator`."],["sep_by1","Applies the parser `R` one or more times, separated by the parser `F`. All matches from `R` will be collected into the type `T: FromIterator`."],["skip_many","Runs the given parser until it fails, discarding matched input."],["skip_many1","Runs the given parser until it fails, discarding matched input, expects at least one match."]],"mod":[["bounded","Bounded versions of combinators."]]});